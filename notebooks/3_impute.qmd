---
title: "3_impute"
output: 
  html_document:
    toc: true 
    toc_depth: 4
editor_options: 
  chunk_output_type: console
---

```{r}
library(conflicted)
conflict_prefer("filter", "dplyr")
conflict_prefer("select", "dplyr")

library(tidyverse)
library(readr)
library(dplyr)
library(tidyr)
library(ggplot2)
library(lubridate)
library(janitor)
library(mice)
library(miceadds)
library(VIM)
library(lme4)

path_ready <- "_data/data_ready"
```

### Setup and merge

Read in data

```{r}
b <- read_csv(here::here(path_ready, "ready_base.csv"), show_col_types = FALSE)

diary <- read_csv(here::here(path_ready, "diary_sub.csv"), show_col_types = FALSE)
```

#### Confirm diary is in long format

```{r}
diary %>%
  count(nid) %>%
  summarise(median=median(n), max=max(n), prop_with_repeats=mean(n>1))

diary %>%
  count(nid) %>%
  count(n)
```
The diary are structured in long format, with one row per event and multiple events nested within participants. A majority of participants (60.5%) contributed more than one event, with a median of two events per participant and up to 19 events for some individuals.

#### Match types and confirm tidy events

```{r}
b <-  b %>%
  mutate(
    nid = as.factor(nid))

b <- b %>% 
    rename(base_id = response_id,
           base_prog = progress,
           base_fin = finished,
           base_dur = duration_in_seconds)

diary <- diary %>%
  mutate(
    nid = as.factor(nid),
    date = as.Date(date),
    eid = response_id   # unique event key
  ) %>%
  arrange(nid, date) %>%
  group_by(nid) %>%
  mutate(event_num = row_number()) %>%
  ungroup()

diary <- diary %>% 
  select(-c(response_id))
```

#### Merge baseline and diary

```{r}
d <- diary %>%
  left_join(b %>% distinct(nid, .keep_all = TRUE), by = "nid")
```

```{r}
d <- d %>% 
  select(-c(osb3:traum4, psb_cub, s_life, med1_p:med4_p, cub3:cub6, au_t:au_drg))

df <- d %>%
  select(nid, eid, day, bpa, fm_r, s_tx, p_tx, drnk, verb, enon, inon,
         sact, prec, gend_di, aud1, aud2, aud3, aud4, aud5, aud6, aud7, aud8, aud9, 
         aud10, asco, irma, ppat, bidr) %>% glimpse()
```

### Explore missingness

NOTE: n = 1 `nid` (9128298) endorsed "Prefer not to respond" for `bpa`
- best conceptualized as item nonresponse. 
- Treat as missing and impute. 
```{r}
df %>% select(bpa) %>% map(tabyl)

df <- df %>%
  mutate(bpa = ifelse(bpa == 3, NA, bpa))
```

```{r}
colSums(is.na(df))[colSums(is.na(df)) > 0]
```

An examination of missing data patterns indicated that missingness was sparse and localized to a small subset of event-level variables. The majority of observations were complete, and no observation exhibited extensive missingness across variables. Given this pattern, multiple imputation with chained equations will be used to address missing data under a missing-at-random assumption.
```{r}
md.pattern(df)
```

Visual and tabular inspection of missing data indicated that missingness was sparse, localized to a small number of event-level variables, and not concentrated within specific participants or events.
```{r}
aggr(df, numbers = TRUE)
```

Prepare vars for imputation
```{r}
df <- df %>%
  mutate(
    across(c(prec, gend_di, bpa), ~ factor(.x, levels = c(0, 1))),
    sact = factor(sact, levels = c("Contact", "Penetration")))

df_imp <- df %>%
  mutate(                       
    nid = as.integer(nid),  # integer cluster id for mice
    eid = factor(eid), # event identifier as factor
    day = as.integer(day)
  )

rm(b, d, diary, df)

df_imp %>% glimpse()
```

### Predictor-matrix rules

Initialize
```{r}
# create default blocks/methods/predictorMatrix
ini <- mice(df_imp, maxit = 0, printFlag = FALSE)

pred   <- ini$predictorMatrix
meth   <- ini$method

# inspect any logged events
ini$loggedEvents
```

Declare cluster for 2-level setup and protect structure vars
```{r}
meth["nid"]   <- ""   # do not impute nid (participant ID) itself
pred[, "nid"] <- -2   # declare nid the cluster variable for 2l.* methods
pred["nid", ] <- 0    # nid is not predicted by anything

# event ID not imputed, not a predictor
meth["eid"]      <- ""
pred[, "eid"]    <- 0
pred["eid", ]    <- 0

# day as auxiliary predictor
meth["day"]   <- "" # (not imputed)
pred["day", ] <- 0   # nid is not predicted by anything
```

Specify methods for variables with missingness
```{r}
meth["aud2"]        <- "pmm"
meth["bpa"]        <- "logreg"
meth["prec"]        <- "logreg"
meth["fm_r"]        <- "2l.pmm"
meth["drnk"]      <- "2l.pmm"
meth["verb"]      <- "2l.pmm"
meth["enon"]     <- "2l.pmm"
meth["inon"]     <- "2l.pmm"

# don't use nonverbal items to impute verbal
pred["verb", c("enon", "inon")] <- 0

# don't use verbal to impute nonverbal items
pred[c("enon", "inon"), "verb"] <- 0

length(df_imp)                 # number of columns
length(ini$blocks)             # number of blocks mice will use
length(ini$method)             # method length expected by those blocks

names(df_imp)
names(ini$method)
```

```{r}
warns <- character(0)

imp <- withCallingHandlers(
  mice(
    df_imp,
    m = 20,
    maxit = 20,
    method = meth,
    predictorMatrix = pred,
    seed = 1234,
    printFlag = TRUE
  ),
  warning = function(w) {
    warns <<- c(warns, conditionMessage(w))
    invokeRestart("muffleWarning")
  }
)

unique(warns)
```

```{r}
imp
```

```{r}
stripplot(imp, fm_r ~ .imp)
stripplot(imp, prec ~ .imp)
stripplot(imp, drnk ~ .imp)
stripplot(imp, enon ~ .imp)
stripplot(imp, inon ~ .imp)
stripplot(imp, verb ~ .imp)
stripplot(imp, aud2 ~ .imp)
```

```{r}
summary(complete(imp, 1)$fm_r) 
summary(complete(imp, 1)$prec)
summary(complete(imp, 1)$drnk)
summary(complete(imp, 1)$enon)
summary(complete(imp, 1)$inon)
summary(complete(imp, 1)$verb)
summary(complete(imp, 1)$aud2)
```

